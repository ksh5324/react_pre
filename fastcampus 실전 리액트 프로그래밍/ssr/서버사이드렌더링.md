# 서버사이드 렌더링 AND Next.js (출처: 실전 리엑트 프로그래밍 개정판)

서버사이드 렌더링(server side rendering)이란 서버에서 리액트 코드를 실행해서 렌더링하는 것을 말한다. 서버사이드 렌더링이 필요한 이유는 다암 두 가지가 대표적이다.

- 검색 엔진 최적화(search engine optimization, SEO)를 해야한다.
- 빠른 첫 페이지 렌더링이 중요하다.

많은 수의 사용자를 대상으로 하는 사이트라면 검색 엔진 최적화를 위해서 서버사이드 렌더링은 필수다. 구글을 제외한 다른 검색 엔진에서는자바스크립트를 실행하지 않기 때문에 클라이언트 렌더링만 하는 사이트는 내용이 없는 사이트와 동일하게 처리된다. 게다가 구글도 서버사이트 렌더링을 하는 사이트에 더 높은 점수를 부여한다고 알려져 있다.

서버사이드 렌더링을 하면 사용자가 요청한 페이지를 빠르게 보여 줄 수 있다. 클러이언트 렌더링만 한다면 자바스크립트를 실행해야만 화면이 보이기 때문에 저사양 기기를 사용하는 사용자일수록 요청한 페이지가 느리게 보인다. 저사양 기기를 사용하는 사람이 많거나 네트워크 인프라가 약한 나라에서 서비스를 해야 한다면 서버사이드 렌더링을 중요하게 생각해야 한다.

이 장에서는 먼저 프레임워크의 도움 없이 직접 서버사이드 렌더링 환경을 구축해 본다. 그리고 서버사이드 렌더링을 지원하는 대표적인 프레임워크인 넥스트를 알아본다.

## 서버사이드 렌더링 초급편

먼저 실습 프로젝트를 만든다.

    npm init -y
    npm i react react-dom

그리고 바벨 실행을 위한 패키지를 설치한다.

    npm i @babel/core @babel/preset-react @babel/preset-env

웹팩을 실행하기 위한 패키지도 설치한다.

    npm i webpack webpack-cli babel-loader clean-webpack-plugin html-webpack-plugin

### 클라이언트에서만 렌더링해 보기

서버사이드 렌더링을 구현하기 위한 사전 작업으로 클라이언트에서만 렌더링하는 웹사이트를 만들어 보자.

프로젝트 루트에 src 폴더를 만들고 그 밑에 Home.js, About.js 파일을 만든다. 각 파일은 웹사이트의 페이지를 나타내며 페이지 전환을 테스트하는 용도로 사용된다. 두 파일의 내용은 다음과 같다.

```js
// Home.js
import React from "react";

const Home = () => {
  return (
    <div>
      <h3>This is home page</h3>
    </div>
  );
};

export default Home;


// About.js
import React from "react";

const About = () => {
  return (
    <div>
      <h3>This is about page</h3>
    </div>
  );
};

export default About;
```

이제는 이 Home.js와 About.js를 렌더링하는 App 컴포넌트를 만들자. App 컴포넌트는 버튼을 통해 각 페이지로 이동할 수 있는 기능을 제공한다. src 폴더 밑에 App.js 파일을 만들고, 다음 코드를 입력한다.

```js
// App.js
import React, { useEffect, useState } from "react";
import About from "./About";
import Home from "./Home";

const App = () => {
  const [page, setPage] = useState(page);
  useEffect(() => {
    window.onpopstate = (event) => {
      // 1
      setPage(event.state);
    };
  }, []);
  function onChangePage(e) {
    // 2
    const newPage = e.target.dataset.page;
    window.history.pushState(newPage, "", `/${newPage}`); // 3
    setPage(newPage);
  }
  const PageComponent = page === "home" ? Home : About; // 4
  return (
    <div className="container">
      <button data-page="home" onClick={onChangePage}>
        Hoem
      </button>
      <button data-page="about" onClick={onChangePage}>
        About
      </button>
      <PageComponent />
    </div>
  );
};

export default App;
```

1 단일 페이지 애플리케이션을 직접 구현하기 위해 onpopstate 이벤트 처리 함수를 등록한다. 브라우저에서 뒤로 가기 버튼을 클릭하면 onpopstate 함수가 호출된다.  
2 특정 페이지로 이동하는 버튼의 이벤트 처리 함수다.  
3 pushState 메서드를 통해 브라우저에게 주소가 변경됐다는 것을 알린다.  
4 page 상탯값에 따라 렌더링할 페이지의 컴포넌트가 결정된다.

src 폴더 밑에 index.js 파일을 만들고 앞에서 만들 App 컴포넌트를 렌더링해 보자.

```js
import React from "react";
import ReactDOM from "react-dom";
import App from "./App";

ReactDOM.render(<App page="Home" />, document.getElementById("root"));
```

render 함수를 이용해서 App 컴포넌트를 돔 요소에 연결한다.

### 웹팩 설정하기

지금까지 작성한 코드를 번들링하기 위해 웹팩 설정 파일을 작성하자. 프로젝트 루트에 webpack.config.js 파일을 만들고 다음 코드를 입력한다.

```js
const path = require("path");
const HtmlWebpackPlugin = require("webpack");

module.exports = {
  entry: "./src/index.js",
  output: {
    filename: "[name].[chunkhash].js",
    path: path.resolve(__dirname, "dist"),
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        use: "babel-loader", // 1
      },
    ],
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: "./template/index.html", // 2
    }),
  ],
  mode: "production",
};
```

1 모든 자바스크립트 파일을 babel-loader로 처리한다.  
2 template/idnex.html 파일을 기반으로 HTML 파일을 생성한다.

2번 코드에서 입력한 HTML 템플릿 파일을 만들어 보자. 프로젝트 루트에 template 폴더를 만들고 그 밑에 index.html 파일을 만든다. index.html 파일의 내용은 다음과 같다.

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>test-ssr</title>
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>
```

### 바벨 설정하기

자바스크립트 파일을 컴파일하기 위해 바벨 설정 파일을 작성해 보자. 먼저 프로젝트 루트에 babel.config.js 파일을 만들고 다음 코드를 입력한다.

```js
const presets = ["@babel/preset-react", "@babel/preset-env"];
const plugins = [];

module.exports = {
  presets,
  plugins,
};
```

babel.config.js 파일의 설정은 babel-loader가 실행될 때 적용된다.

### 클라이언트 렌더링 확인하기

클라이언트에서만 렌더링 하는 간단한 웹사이트의 코드를 모두 작성했다. 웹팩을 실행해 보자.

    npx webpack

## 서버사이드 렌더링 함수 사용해 보기: renderToString

이제는 서버사이드 렌더링을 할 차례다. 리액트에서는 서버사이드 렌더링을 위해 네 개의 함수를 제공한다.

- renderToString
- renderToNodeStream
- renderToStaticMarkup
- renderToStaticNodeStream
